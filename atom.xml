<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hugh's Blog]]></title>
  <link href="http://jiangrongyong.github.com/atom.xml" rel="self"/>
  <link href="http://jiangrongyong.github.com/"/>
  <updated>2013-09-02T15:27:44+00:00</updated>
  <id>http://jiangrongyong.github.com/</id>
  <author>
    <name><![CDATA[Hugh]]></name>
    <email><![CDATA[jiangrongyong@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[traits in php 5.4]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/09/02/php-traits/"/>
    <updated>2013-09-02T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/09/02/php-traits</id>
    <content type="html"><![CDATA[<blockquote><p>自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p>

<p>Traits 是一种为类似 PHP 的单继承语言而准备的代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法集。Traits 和类组合的语义是定义了一种方式来减少复杂性，避免传统多继承和混入类（Mixin）相关的典型问题。</p>

<p>Trait 和一个类相似，但仅仅旨在用细粒度和一致的方式来组合功能。Trait 不能通过它自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用类的成员不需要继承。</p></blockquote>

<p>可以用此关键字实现多继承，类似Ruby中的<code>Mixin</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OSX 文件系统大小写不敏感]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/09/02/osx-file-system-case-insensitive/"/>
    <updated>2013-09-02T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/09/02/osx-file-system-case-insensitive</id>
    <content type="html"><![CDATA[<p>HFS+(Mac文件系统)一般配置是大小写不敏感但大小写保留，意思是文件系统会认为<code>foo</code>和<code>FoO</code>是同一个文件，但当创建该文件时系统就记住哪个字母大写哪个小写</p>

<p>当格式化成HFS+格式时你可以指定文件系统是否大小写敏感。但如果你格式化成UFS(Unix FileSystem)的话将会永远是大小写敏感</p>

<p>检查你的磁盘格式是否大小写敏感</p>

<pre><code>diskutil info &lt;device&gt;
</code></pre>

<p>例如</p>

<pre><code>diskutil info /dev/disk0s2
</code></pre>

<p><code>Name (User Visible):      Mac OS Extended (Journaled)</code></p>

<p>如果是<code>Mac OS Extended (Case-sensitive, Journaled)</code>则表示大小写敏感，如果没有<code>Case-sensitive</code>字样则仅仅是大小写保留非大小写敏感。</p>

<hr />

<p>http://apple.stackexchange.com/questions/22297/is-bash-in-osx-case-insensitive</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim批量注释]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/08/30/vim-comment/"/>
    <updated>2013-08-30T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/08/30/vim-comment</id>
    <content type="html"><![CDATA[<ul>
<li><p>批量注释</p>

<ol>
<li><code>ctrl+v</code> 进入列编辑模式</li>
<li>上下移动光标,把需要注释的行的开头选中</li>
<li><code>shift+i</code>,插入注释符,比如<code>//</code></li>
<li><code>Esc</code>,就会全部注释了</li>
</ol>
</li>
<li><p>批量去掉注释</p>

<ol>
<li><code>ctrl+v</code>,进入列编辑模式</li>
<li>横向选中列的个数，如<code>//</code>注释符号</li>
<li>按<code>d</code>, 就会删除注释符号</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[防止ssh过一段时间后中断]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/08/29/sshd-interrupt/"/>
    <updated>2013-08-29T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/08/29/sshd-interrupt</id>
    <content type="html"><![CDATA[<pre><code>$ sudo vim /etc/ssh/sshd_config
</code></pre>

<p>修改</p>

<pre><code># 如果超过15秒后没有收到客户端的任何数据，sshd将通过安全通道向客户端发送一个"alive"消息，并等候应答，默认值0表示不发送
ClientAliveInterval 15

# sshd在未收到任何客户端回应前最多允许发送45个"alive"消息，默认值3
ClientAliveCountMax 45
</code></pre>

<p>重启sshd</p>

<pre><code>$ sudo /etc/init.d/sshd restart
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php cookie deleted]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/08/19/php-cookie-deleted/"/>
    <updated>2013-08-19T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/08/19/php-cookie-deleted</id>
    <content type="html"><![CDATA[<p>使用<code>setcookie('name', '')</code>方式删除cookie时，PHP将cookie的值设置为<code>deleted</code>，过期时间设置为一年前。如果用户本地时间为两年前，则该cookie没有被删除，而是将值设置为了deleted。</p>

<p>比较靠谱的删除cookie的方法为：</p>

<pre><code>setcookie('name', 'deleted', 1, $path, $domain);
</code></pre>

<p>注意：在PHP5.2版本之前(包含5.2)，cookie的值可以不是deleted，但是不能为空，否则，时间参数将不被参考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php utf-8 bom]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/08/07/php-utf8-bom/"/>
    <updated>2013-08-07T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/08/07/php-utf8-bom</id>
    <content type="html"><![CDATA[<h3>1. 测试接口是否有返回有BOM</h3>

<pre><code>curl -s http://i.wan.liebao.cn/ | head -1 |sed -n l

# 有BOM情况
\357\273\277{"data":{"uname":"jiangrongyong","s_face":"http:\/\/static.hdslb.com\/images\/member\/noface.gif"},"msg":"ok","code":1}

# 无BOM情况    
{"data":{"uname":"jiangrongyong","s_face":"http:\/\/static.hdslb.com\/images\/member\/noface.gif"},"msg":"ok","code":1}
</code></pre>

<h3>2. vim设置BOM</h3>

<p>设置utf-8编码</p>

<pre><code>:set fileencoding=utf-8
</code></pre>

<p>添加BOM</p>

<pre><code>:set bomb
</code></pre>

<p>删除BOM</p>

<pre><code>:set nobomb
</code></pre>

<p>检测是否有BOM</p>

<pre><code>:set bomb?
</code></pre>

<h3>3. 查找有BOM的文件</h3>

<pre><code>grep -r -I -l $'^\xEF\xBB\xBF' $path
</code></pre>

<h3>4. 批量删除BOM</h3>

<pre><code>grep -r -I -l $'^\xEF\xBB\xBF' /path | xargs sed -i 's/^\xEF\xBB\xBF//;q'
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tmux]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/08/04/tmux/"/>
    <updated>2013-08-04T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/08/04/tmux</id>
    <content type="html"><![CDATA[<p>最近介绍tmux的文章好多，虽然已久仰大名，今天试用了一下，果然是神器。没用过screen，直接跳级使用tmux。。</p>

<p>记录下常用操作</p>

<p>输入<code>tmux</code>，进入tmux模式</p>

<p><code>tmux attach -t {session_name}</code> attach到某个session</p>

<p><code>tmux kill-session -t {session_name}</code> kill掉某个session</p>

<p><code>control + b</code> 操作入口</p>

<p><code>"</code> pane水平切割</p>

<p><code>%</code> pane纵向切割</p>

<p><code>$</code> 重命名session</p>

<p><code>d</code> detach tmux</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fibonacci Algorithm]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/08/04/fibonacci/"/>
    <updated>2013-08-04T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/08/04/fibonacci</id>
    <content type="html"><![CDATA[<p><code>1,1,2,3,5,8,13,21</code>依次类推下去，你会发现，它后一个数等于前面两个数的和。在这个数列中的数字，就被称为斐波那契数(Fibonacci Sequence)。</p>

<p>任何相邻的两个数，次第相除(如8/13,13/21)，其比率都最为接近<code>0.618</code>这个值，它的极限就是所谓的&#8221;黄金分割数&#8221;。</p>

<p>递推关系</p>

<pre><code>f(1)=1
f(2)=1
f(n)=f(n-1)+f(n-2) //n&gt;=2
3f(n)=f(n+2)+f(n-2)
</code></pre>

<p>用PHP打印斐波那契数</p>

<pre><code>&lt;?php
function fib($n) {
    if($n &lt;= 1) {
        return $n;
    }
    return fib($n - 1) + fib($n - 2);
}

for($i = 0; $i &lt; 9; $i++) {
    echo fib($i) . ' ';
}
</code></pre>

<p>github source</p>

<p><a href="">https://github.com/jiangrongyong/algorithm</a></p>

<p>优化方案，加入缓存
Ruby</p>

<pre><code>def fibonacci(n, cache=Hash[[[0,0],[1,1]]])
    return cache[n] if cache[n]
    cache[n] = fibonacci(n-2, cache) + fibonacci(n-1, cache)
end
puts (1...1000).to_a.collect{|t| fibonacci(t) }.join(', ')
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Good Parts]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/07/24/php-good-parts/"/>
    <updated>2013-07-24T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/07/24/php-good-parts</id>
    <content type="html"><![CDATA[<ol>
<li><p>list函数</p>

<pre><code> list($table, $field)=explode('.', $field);
 $query = $this-&gt;CI-&gt;db-&gt;limit(1)-&gt;get_where($table, array($field =&gt; $str));
</code></pre></li>
<li><p>%s</p>

<pre><code> $lang['required'] = "The %s field is required.";
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim打开nginx conf时语法高亮]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/30/vim-nginx-syntax-on/"/>
    <updated>2013-06-30T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/30/vim-nginx-syntax-on</id>
    <content type="html"><![CDATA[<pre><code>mkdir -p ~/.vim/syntax/

wget -O ~/.vim/syntax/nginx.vim http://www.vim.org/scripts/download_script.php?src_id=14376

# /usr/local/etc/nginx/vhosts/*为nginx配置文件存放目录
echo "au BufRead,BufNewFile /usr/local/etc/nginx/vhosts/* set ft=nginx" &gt;&gt; ~/.vim/filetype.vim
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OSX Snap]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/20/osx-snap/"/>
    <updated>2013-06-20T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/20/osx-snap</id>
    <content type="html"><![CDATA[<p>Snap，终于找到这款<code>command + 数字</code>启动应用的神器，今天还限免</p>

<p>https://itunes.apple.com/cn/app/id418073146?mt=12</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn在已经commit情况下回滚代码]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/16/svn-merge/"/>
    <updated>2013-06-16T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/16/svn-merge</id>
    <content type="html"><![CDATA[<ol>
<li><p>保证代码最新</p>

<pre><code> svn update
</code></pre></li>
<li><p>查看要回滚代码的提交日志</p>

<pre><code> svn log [something]
</code></pre></li>
<li><p>对比该文件老版本和最新版本有什么不同，以下28是最新版本，25是需要回滚到的版本</p>

<pre><code> svn diff -r 28:25 [something]
</code></pre></li>
<li><p>回滚到版本25</p>

<pre><code> svn merge -r 28:25 [something]
</code></pre></li>
<li><p>为保险起见，再对比一下</p>

<pre><code> svn diff [something]
</code></pre></li>
<li><p>提交回滚</p>

<pre><code> svn commit -m "Revert revision from r28 to r25,because of ..."
</code></pre></li>
</ol>


<hr />

<p>参考文章：</p>

<ul>
<li>http://blog.sina.com.cn/s/blog_5432f2730100vmz4.html</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Html Email 注意事项]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/16/html-email/"/>
    <updated>2013-06-16T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/16/html-email</id>
    <content type="html"><![CDATA[<ol>
<li>Doctype使用XHTML 1.0 Strict，不能用HTML5</li>
<li><p>使用table布局</p>

<pre><code> &lt;body style="margin: 0; padding: 0;"&gt;
 　&lt;table border="1" cellpadding="0" cellspacing="0" width="100%"&gt;
 　　&lt;tr&gt; 
 　　　&lt;td&gt; Hello! &lt;/td&gt;
 　　&lt;/tr&gt;
 　&lt;/table&gt;
 &lt;/body&gt;
</code></pre></li>
<li><p>图片是唯一可以引用的外部资源。其他的外部资源，比如样式表文件、字体文件、视频文件等，一概不能引用。</p></li>
<li>所有的CSS规则，最好都采用行内样式。因为放置在网页头部的样式，很可能会被客户端删除。客户端对CSS规则的支持情况，请看这里。</li>
<li><p>Content-Type要使用</p>

<pre><code> Content-Type: Multipart/Alternative;
</code></pre></li>
</ol>


<hr />

<p>参考文章</p>

<ul>
<li>http://www.ruanyifeng.com/blog/2013/06/html_email.html</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OSX 无共享的密钥情况下连接基于L2TP协议的VPN]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/14/osx-vpn-l2tp/"/>
    <updated>2013-06-14T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/14/osx-vpn-l2tp</id>
    <content type="html"><![CDATA[<p>由于公司VPN使用的是L2TP协议，并且是无共享密钥的，OS X需要作一些配置才能支持，否则会提示<code>“IPSec 共享密钥”丢失。请验证您的设置并尝试重新连接。</code></p>

<ol>
<li><p><code>sudo vim /etc/ppp/options</code></p>

<pre><code> plugin L2TP.ppp
 l2tpnoipsec
</code></pre></li>
<li><p>最后把高级设置里面”通过VPN连接发送所有流量“钩上</p></li>
</ol>


<p>2013-06-16 更新</p>

<p>iOS也可以用同样方法，不过必须越狱，建议安装openssh，然后ssh到iOS设备修改文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用MAKEFILE自动化部署]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/14/makefile-autodeploy/"/>
    <updated>2013-06-14T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/14/makefile-autodeploy</id>
    <content type="html"><![CDATA[<p>自动提交本地git，然后ssh到服务器更新和部署，终于优雅实现这个一直很久的需求了</p>

<p>vim Makefile</p>

<pre><code> PROJECT=free-will.me
 SERVER=hugh@106.187.34.61
 PATH=/data/app/octopress/
 SSH=/usr/bin/ssh
 GIT=/usr/bin/git
 AWK=/usr/bin/awk
 XARGS=/usr/bin/xargs
 LOCAL_PATH=/Users/jiangrongyong/Program/jiangrongyong.github.com

 remote_deploy:
        @cd $(LOCAL_PATH)
        @$(GIT) status -s|$(AWK) '{print $$2}'|$(XARGS) $(GIT) add
        @$(GIT) commit -m "posts update"
        @$(GIT) push -u origin source
        @$(SSH) -t $(SERVER) "echo Deploy $(PROJECT) to the $(SERVER) server.; cd $(PATH); git pull; rake gen_deploy;"
</code></pre>

<p>参考文章</p>

<ul>
<li>http://tchen.me/posts/2013-06-12-use-makefile-to-automate-deployment.html</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OSX下使用dd命令把镜像文件烧进SD卡]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/06/14/dd/"/>
    <updated>2013-06-14T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/06/14/dd</id>
    <content type="html"><![CDATA[<ol>
<li><code>df -h</code></li>
<li><code>unmount /dev/disk1s1</code></li>
<li><code>diskutil list</code></li>
<li><code>dd bs=4m if=raspbmc-final.img of=/dev/rdisk1</code></li>
</ol>


<p>以上4步就ok了</p>

<p>参考来源</p>

<ul>
<li>http://zhangshenjia.com/exprience/mac-raspbian/</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XMPP与Openfire]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/05/04/xmpp/"/>
    <updated>2013-05-04T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/05/04/xmpp</id>
    <content type="html"><![CDATA[<p>准备做一个实时应用的服务端，由于以前都是基于http协议开发的，没有这方面的经验</p>

<p>查了下V2EX和知乎，发现目前国内大部分成熟应用用的协议都是XMPP，如米聊、微信和国外的kik</p>

<p>以下是知乎上对XMPP的评价</p>

<blockquote><p>使用XMPP协议（Openfire + Spark + Smack）
简介：基于XML协议的通讯协议，前身是Jabber，目前已由IETF国际标准化组织完成了标准化工作。
优点：协议成熟、强大、可扩展性强、目前主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。
缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。</p></blockquote>

<h3>1. 部署开发环境</h3>

<h4>1.1 参考文章</h4>

<ul>
<li><a href="http://www.igniterealtime.org/projects/openfire/">Home page</a></li>
<li><a href="http://www.igniterealtime.org/downloads/index.jsp">Download page</a></li>
<li><a href="http://www.jabbercn.org/Openfire:%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">中文wiki</a></li>
<li><a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/source-build.html">Building the Source</a></li>
<li><a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/javadoc/index.html">Javadoc</a></li>
<li><a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/plugin-dev-guide.html">Openfire Plugin Developer Guide</a></li>
<li><a href="http://community.igniterealtime.org/docs/DOC-1020">官方部署开发环境文档 - Openfire SVN + Eclipse 3.3 + Subversive Installation Guide</a></li>
<li><a href="http://blog.csdn.net/ares1201/article/details/7737872">Openfire开发配置,Openfire源代码配置,OpenFire二次开发配置</a></li>
<li><a href="http://lmain.blog.51cto.com/779468/157942">Openfire源码布署与打包</a></li>
<li><a href="http://www.blogjava.net/yi88han/archive/2009/02/10/gissing.html">openfire开发文档</a></li>
<li><a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/database-guide.html">Database Schema Guide</a></li>
<li><a href="http://zhuyx808.iteye.com/blog/414796">OpenFire客户端编程示例</a></li>
<li></li>
<li><a href="http://android-zhang.iteye.com/blog/1836312">Android基于XMPP Smack Openfire开发IM【一】登录openfire服务器</a></li>
<li><a href="http://android-zhang.iteye.com/blog/1836603">Android基于XMPP Smack Openfire开发IM 【二】获取好友列表</a></li>
<li><a href="http://android-zhang.iteye.com/blog/1836776">Android基于XMPP Smack Openfire开发IM【三】客户端接收服务器发送的消息</a></li>
<li><a href="http://android-zhang.iteye.com/blog/1837189">Android基于XMPP Smack Openfire开发IM【四】初步实现两个客户端通信</a></li>
<li></li>
<li><a href="http://blog.csdn.net/windone0109/article/details/4675944">即时通讯软件openfire+spark+smack</a></li>
<li><a href="http://hetylei.iteye.com/blog/290519">xmpp with openfire之四 扩展的AuthProvider</a></li>
<li><a href="http://www.docin.com/p-210007713.html">XMPP协议及其服务器端的Openfire插件开发</a></li>
<li></li>
<li><a href="http://hetylei.iteye.com/blog/289854">xmpp with openfire之一 xmpp and openfire</a></li>
<li><a href="http://hetylei.iteye.com/blog/290031">xmpp with openfire之二 openfire安装</a></li>
<li><a href="http://hetylei.iteye.com/blog/290140">xmpp with openfire之三 openfire扩展小试 整合现有系统用户</a></li>
<li><a href="http://hetylei.iteye.com/blog/290519">xmpp with openfire之四 扩展的AuthProvider</a></li>
<li><a href="http://hetylei.iteye.com/blog/291265">xmpp with openfire之五 插件－利用Broadcast实现群</a></li>
<li></li>
<li><a href="http://blog.csdn.net/hexudong08/article/details/7429402">openfire 开发插件</a></li>
<li><a href="http://blog.csdn.net/hexudong08/article/details/7450206">openfire插件开发续一(xmpp4r)</a></li>
<li><a href="http://blog.csdn.net/hexudong08/article/details/7454283">openfire插件开发续二</a></li>
<li><a href="http://blog.csdn.net/hexudong08/article/details/7460246">openfire插件开发三，java端开发</a></li>
<li></li>
<li><a href="http://www.cnblogs.com/ErinCodeMM/archive/2011/12/25/2301220.html">【openfire插件开发】IQHandler处理IQ请求包（模板方法模式）</a></li>
<li><a href="http://forum.rooyeetone.com/simple/?t199.html">openfire开发文档</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_a4cf4b4301010rdb.html">openfire插件开发最简单的demo</a></li>
<li><a href="http://wenku.baidu.com/view/ccc01e6f7e21af45b307a88b.html">Openfire插件开发流程</a></li>
<li><a href="http://blog.csdn.net/sapphire_aling/article/details/6677979">openfire+smack新用户注册、更改用户状态</a></li>
<li><a href="http://blog.csdn.net/lnb333666/article/details/7598683">Android基于XMPP Smack openfire 开发的聊天室（四） 【创建房间、表单；报文】</a></li>
<li><a href="http://www.hutud.com/index.php/archives/328">spark openfire conference修改使群组编程持久的。 类似qq群（1）</a></li>
<li><a href="http://www.cnblogs.com/huazai8204/archive/2011/12/31/2309022.html">改造MUC实现Openfire群</a></li>
<li><a href="http://www.jabbercn.org/XEP-0045#.E6.88.BF.E9.97.B4.E7.B1.BB.E5.9E.8B">XEP-0045: 多用户聊天</a></li>
<li><a href="http://www.igniterealtime.org/builds/openfire/docs/latest/documentation/database-guide.html">Database Schema Guide</a></li>
</ul>


<h4>1.2 Mac下启动与关闭Openfire（通过dmg包安装）</h4>

<p>关闭</p>

<pre><code>sudo launchctl unload /Library/LaunchDaemons/org.jivesoftware.openfire.plist
</code></pre>

<p>启动</p>

<pre><code>sudo launchctl load /Library/LaunchDaemons/org.jivesoftware.openfire.plist
</code></pre>

<p><a href="http://community.igniterealtime.org/thread/38670">原文</a></p>

<h4>1.3 编译源码</h4>

<h5>1.3.1 ant编译</h5>

<pre><code>cd /Users/jiangrongyong/Program/openfire_src/build

ant openfire
</code></pre>

<h5>1.3.2 启动openfire</h5>

<pre><code>#先启动mysql
/usr/local/mysql/bin/mysqld

#openfire启动脚本
/Users/jiangrongyong/Program/openfire_src/target/openfire/bin/openfire.sh start
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash加强history]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/04/26/enhance-history/"/>
    <updated>2013-04-26T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/04/26/enhance-history</id>
    <content type="html"><![CDATA[<p>我们知道在 bash 里，可以通过 “上下” 键来浏览最近执行过的命令历史纪录（history），我们也知道如果历史纪录太多的话可以通过 ctrl+r 来查找命令或者通过 history 命令来浏览历史命令。我们不知道的是（也许只有本人不知道～），还有一种神奇的办法可以更准确、有效的在历史命令纪录中查找自己想要的命令。</p>

<p>在自己的用户主目录（home directory）新建一个 <code>.inputrc</code> 文件：</p>

<pre><code>$ vi ~/.inputrc

"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on
</code></pre>

<p>退出 bash 后重新登陆，敲打一个字母或者几个字母，然后 “上下” 键，就会看到以这个字母搜索到的完整命令行。如果搜索到几个类似命令，通过上下键来切换，有点像 ctrl+r，但是更好用。</p>

<p><a href="http://feedproxy.google.com/~r/vpsee/~3/sC2N167c_c4/">原文</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Centos下搭建ftp]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/04/17/centos-vsftpd/"/>
    <updated>2013-04-17T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/04/17/centos-vsftpd</id>
    <content type="html"><![CDATA[<p>vsftpd作为FTP服务器，在Linux系统中是非常常用的。下面我们介绍如何在centos系统上安装vsftp。</p>

<h3>什么是vsftpd</h3>

<p>vsftpd是一款在Linux发行版中最受推崇的FTP服务器程序。特点是小巧轻快，安全易用。</p>

<p>vsftpd 的名字代表”very secure FTP daemon”, 安全是它的开发者 Chris Evans 考虑的首要问题之一。在这个 FTP 服务器设计开发的最开始的时候，高安全性就是一个目标。</p>

<h3>安装vsftpd</h3>

<ol>
<li><p>以管理员（root）身份执行以下命令</p>

<pre><code> yum install vsftpd
</code></pre></li>
<li><p>设置开机启动vsftpd ftp服务</p>

<pre><code> chkconfig vsftpd on
</code></pre></li>
<li><p>启动vsftpd服务</p>

<pre><code> service vsftpd start
</code></pre></li>
</ol>


<h3>管理vsftpd相关命令</h3>

<ol>
<li><p>停止vsftpd</p>

<pre><code> service vsftpd stop
</code></pre></li>
<li><p>重启vsftpd</p>

<pre><code> service vsftpd restart
</code></pre></li>
<li><p>配置防火墙</p>

<p> 打开/etc/sysconfig/iptables文件</p>

<pre><code> vi /etc/sysconfig/iptables
</code></pre>

<p> 在REJECT行之前添加如下代码</p>

<pre><code> -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT
</code></pre>

<p> 保存和关闭文件，重启防火墙</p>

<pre><code> service iptables start
</code></pre>

<p> 配置vsftpd服务器</p>

<p> 默认的配置文件是/etc/vsftpd/vsftpd.conf，你可以用文本编辑器打开。</p>

<pre><code> vi /etc/vsftpd/vsftpd.conf
</code></pre></li>
</ol>


<h3>添加ftp用户</h3>

<p>下面是添加ftpuser用户，设置根目录为/home/wwwroot/ftpuser,禁止此用户登录SSH的权限，并限制其访问其它目录。</p>

<ol>
<li><p>修改/etc/vsftpd/vsftpd.conf</p>

<p> 将底下三行</p>

<pre><code> #chroot_list_enable=YES
 # (default follows)
 #chroot_list_file=/etc/vsftpd.chroot_list
</code></pre>

<p> 改为</p>

<pre><code> chroot_list_enable=YES
 # (default follows)
 chroot_list_file=/etc/vsftpd/chroot_list
</code></pre></li>
<li><p>增加用户ftpuser，指向目录/home/wwwroot/ftpuser,禁止登录SSH权限。</p>

<pre><code> useradd -d /home/wwwroot/ftpuser -g ftp -s /sbin/nologin ftpuser
</code></pre></li>
<li><p>设置用户口令</p>

<pre><code> passwd ftpuser
</code></pre></li>
<li><p>编辑文件chroot_list:</p>

<pre><code> vi /etc/vsftpd/chroot_list
</code></pre>

<p> 内容为ftp用户名,每个用户占一行,如：</p>

<pre><code> peter
 john
</code></pre></li>
<li><p>重新启动vsftpd</p>

<pre><code> service vsftpd restart
</code></pre></li>
</ol>


<p><a href="http://www.centos.bz/2011/03/centos-install-vsftpd-ftp-server/">转载自</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql忘记密码]]></title>
    <link href="http://jiangrongyong.github.com/blog/2013/04/11/mysql-forgot-password/"/>
    <updated>2013-04-11T00:00:00+00:00</updated>
    <id>http://jiangrongyong.github.com/blog/2013/04/11/mysql-forgot-password</id>
    <content type="html"><![CDATA[<p>当忘记MySQL的root密码的时候，可以进行如下的步骤重新设置MySQL的root密码：</p>

<p>1．首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。
因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的
状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对
外的端口封闭，并且停止Apache以及所有的用户进程的方法实现服务器的准安全
状态。最安全的状态是到服务器的Console上面操作，并且拔掉网线。</p>

<p>2．修改MySQL的登录设置：</p>

<pre><code>vi /etc/my.cnf 
</code></pre>

<p>在[mysqld]的段中加上一句：skip-grant-tables
例如：</p>

<pre><code>[mysqld] 
datadir=/var/lib/mysql 
socket=/var/lib/mysql/mysql.sock 
skip-grant-tables 
</code></pre>

<p>保存并且退出vi。</p>

<p>3．重新启动mysqld</p>

<pre><code>/etc/init.d/mysqld restart 

Stopping MySQL: [ OK ] 
Starting MySQL: [ OK ] 
</code></pre>

<p>4．登录并修改MySQL的root密码</p>

<pre><code>/usr/bin/mysql 


Welcome to the MySQL monitor. Commands end with ; or \g. 
Your MySQL connection id is 3 to server version: 3.23.56 

Type 'help;' or '\h' for help. Type '\c' to clear the buffer. 

mysql&gt; USE mysql ; 
Reading table information for completion of table and column names 
You can turn off this feature to get a quicker startup with -A 

Database changed 
mysql&gt; UPDATE user SET Password = password ( 'new-password' ) WHERE User = 'root' ; 
Query OK, 0 rows affected (0.00 sec) 
Rows matched: 2 Changed: 0 Warnings: 0 

mysql&gt; flush privileges ; 
Query OK, 0 rows affected (0.01 sec) 

mysql&gt; quit 
Bye 
</code></pre>

<p>5．将MySQL的登录设置修改回来</p>

<pre><code>vi /etc/my.cnf 
</code></pre>

<p>将刚才在[mysqld]的段中加上的skip-grant-tables删除
保存并且退出vi。</p>

<p>6．重新启动mysqld</p>

<pre><code>/etc/init.d/mysqld restart 

Stopping MySQL: [ OK ] 
Starting MySQL: [ OK ] 
</code></pre>

<p>7．恢复服务器的正常工作状态
将步骤一中的操作逆向操作。恢复服务器的工作状态。</p>
]]></content>
  </entry>
  
</feed>
